@Attach NeImpl
Eq(R |= Self()) = Trait {
    .`==` = Self(R).(R) -> Bool
}

NeImpl R = Patch Eq R
NeImpl(R).`!=`(self, other: R): Bool = not(self == other)

# Should this return `Ordering`?
@Attach EqImpl, GeImpl, GtImpl, LtImpl
Ord(R |= Self()) = Trait {
    .`<=` = Self(R).(R) -> Bool
}

EqImpl R = Patch Ord(R), Impl: Eq()
EqImpl(R).`==`(self, other: R): Bool = self <= other and other <= self

GeImpl = Patch Ord()
GeImpl.`>=`(self, other: Self): Bool = other <= self
GtImpl = Patch Ord()
GtImpl.`>`(self, other: Self): Bool = other < self
LtImpl = Patch Ord()
LtImpl.`<`(self, other: Self): Bool = self <= other and self != other

Add(R |= Self) = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -> Self.AddO
}
Sub(R |= Self) = Trait {
    .SubO = Type
    .`_-_` = Self.(R) -> Self.SubO
}
Mul(R |= Self()) = Trait {
    .MulO = Type
    .`*` = Self.(R) -> Self.MulO
}
Div(R |= Self) = Trait {
    .DivO = Type
    .`/` = Self.(R) -> Self.DivO or Panic
}
Num: (R |= Type) -> Type
Num = Add and Sub and Mul

Seq T = Trait {
    .__len__ = Ref(Self).() -> Nat
    .get = Ref(Self).(Nat) -> T
}

`_+_`: |R: Type, A <: Add(R)| (A, R) -> A.AddO
`_-_`: |R: Type, S <: Add(R)| (S, R) -> S.SubO
`*`: |R, O: Type, M <: Add(R)| (M, R) -> M.MulO
`/`: |R, O: Type, D <: Add(R)| (D, R) -> D.DivO

AddForInt = Patch Int, Impl: Add()
AddForInt.`_+_`: (self: Self, other: Int) -> Int

# TODO: Mul and Div
NumForInterval M, N, O, P: Int =
    Patch M..N, Impl: Add(R: O..P) and Sub(R: O..P)
NumForInterval(M, N, O, P).`_+_`: (self: Self, other: O..P) -> M+O..N+P
NumForInterval(M, N, O, P).`_-_`: (self: Self, other: O..P) -> M-P..N-O

Read = Trait {
    .read = Ref(Self).() -> Str
}
Read! = Trait {
    .read! = Ref!(Self).() => Str
}
Write! = Trait {
    .write! = Ref!(Self).(Str) => ()
}
