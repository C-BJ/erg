# メモリ管理

ErgはPythonをホスト言語にした言語であるため、メモリ管理の方法はPythonの処理系に依存している。
しかし意味論的には、Ergのメモリ管理はPythonのそれとは別物である。顕著な違いは、所有権システムと循環参照の禁止に現れている。

## 所有権

ErgはRustから影響を受けた所有権システムを持っている。
Rustの所有権システムは一般的に難解だと言われているが、Ergのそれは直感的になるよう簡略化されている。
Ergでは __可変オブジェクト__ に所有権がついており、所有権を失った後はそのオブジェクトを参照できない。

```erg
v = [1, 2, 3].into [Int; !3]

push! vec, x =
    vec.push!(x)
    vec

# vの中身([1, 2, 3])の所有権はwに移る
w = push! v, 4
print! v # error: v was moved
print! w # [1, 2, 3, 4]
```

所有権の移動はオブジェクトをサブルーチンに渡したときなどに発生する。
渡した後も所有権をまだ持っていたい場合は、複製(cloning)、凍結(freeze)、または借用(borrowing)をする必要がある。
ただし後述するように借用はできる場面が限られている。

## 複製

オブジェクトを複製してその所有権を移す。実引数に`.clone`メソッドを適用することで行う。
複製したオブジェクトは複製元のオブジェクトと全く同一になるが、互いに独立しているので、変更の影響は受けない。

複製はPythonのディープコピーに相当し、同一のオブジェクトをまるごと作り直すので、凍結・借用と比べて一般に計算コスト、メモリコストが高い。
オブジェクトを複製する必要があるようなサブルーチンは、「引数を消費する」サブルーチンという。

```erg
capitalize s: Str! =
    s.capitalize!()
    s

s1 = !"hello"
s2 = capitalize s1.clone()
log s2, s1 # !"HELLO hello"
```

## 凍結

不変オブジェクトは複数の場所から参照できることを利用して、可変オブジェクトを不変オブジェクトに変換してしまう。
これを凍結という。凍結は可変配列からイテレータを作るときなどで使われる。
可変配列からは直接イテレータを作ることができないので、不変配列に変換するのである。
配列を壊したくない場合は、[`.freeze_map`メソッド](./type/mut.md)等を使う。

```erg
# イテレータが出す値の合計を計算する
sum|T <: Add + HasUnit| i: Iterator T = ...

x = [1, 2, 3].into [Int; !3]
x.push!(4)
i = x.iter() # TypeError: [Int; !4] has no method `iter`
y = x.freeze()
i = y.iter()
assert sum(i) == 10
y # この後もyは触れられる
```

## 借用

借用は複製や凍結よりも低コストである。
以下のような単純な場合では、借用を行える。

```erg
peek_str ref(s: Str!) =
    log s

s = !"hello"
peek_str s
```

借用した値は元のオブジェクトに対する __参照__ と呼ばれる。
参照をまた別のサブルーチンに渡す「又貸し」はできるが、借りているだけなので消費することはできない。

```erg
steal_str ref(s: Str!) =
    # log関数は引数を借用するだけなので、又貸しできる
    log s
    # discard関数は引数を消費するので、エラー
    discard s # OwnershipError: cannot consume a borrowed value
    # hint: use `clone` method
```

```erg
steal_str ref(s: Str!) =
    # これもダメ(=は右辺を消費する)
    x = s # OwnershipError: cannot consume a borrowed value
    x
```

Ergの参照はRustより制約が強い。参照は言語上第一級のオブジェクトであるが、明示的に生成することはできず、`ref`/`ref!`によって実引数の渡し方として指定できるのみである。
これは、参照を配列に詰めたり参照を属性とするクラスを作ったりはできないということを意味する。

とはいえ、このような制約はそもそも参照のない言語では当たり前の仕様であり、そこまで不便となることはない。

## 循環参照

Ergでは意図せずメモリリークを起こせないように設計されており、メモリーチェッカーが循環参照を検知するとエラーを出す。ほとんどの場合、このエラーは弱参照`Weak`で解消できる。しかしこれでは巡回グラフなどの循環構造を持つオブジェクトを生成できないため、unsafe操作として循環参照を生成できるAPIを実装予定である。

<p align='center'>
    <a href='./17_mutability.md'>Previous</a> | <a href='./19_visibility.md'>Next</a>
</p>
