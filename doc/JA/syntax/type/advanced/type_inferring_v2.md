# 型推論

> __Warning__: この項の情報は古く、一部に間違いを含みます。

Ergでは多くの場合サブルーチンの引数の型、および戻り値型を省略できる。
この項では、その推論アルゴリズムと、推論ができない場合について解説する。

以下に示す`id`関数は最もシンプルな多相型関数である。

```erg
id x = x
```

xの型は特に指定されていないが、これは以下のコードと同じである。

```erg
id: |T| T -> T
id x = x
```

実際、型指定の省略されている部分は、内部的には`id: |'1, '2| '1 -> '2`と一旦型変数が割り当てられる
(仮に割り振られた型変数は`'数字`で表現することとする)。
そして、ブロック内での`x`の使われ方によって`'2`の型が決定される。
この場合はそのまま返しているので、`'2`型は`'1`型に単一化される。

次に、単相サブルーチンを使用しているサブルーチンの推論を見る。

```erg
p! x = x.times! do! print! x
```

```erg
p!: '1 => '2
print!: ...Object => NoneType
do!: () => NoneType
.times!: Nat.(() => NoneType) => NoneType
'1 := Nat, '2 := NoneType
```

中で使用している`.times!`の戻り値型が単相(一つの種類の型しか受け付けない)なので、`p!`も単相である。
もう少し複雑な例を見る。今度は多相サブルーチンを含むサブルーチンの型推論である。

```erg
f x, y, z = x + y + z
```

まず、このように型が割り当てられる。

```erg
f: ('1, '2, '3) -> '4
f x, y, z = x + y + z
```

`x + y`について、この型は`+`('1, '2)である。フィットするものを`+`の実装及び宣言から探索する。
グローバル空間には``+`: ('L, 'R) -> 'O`という宣言が存在する。この場合これがフィットする。
では`+`('1, '2)の型は何だろうか。単純に'Oとしてはいけない。なぜなら、(x + y) + zの型、
すなわち`+`(`+`('1, '2), '3)もフィットするため、x+yとx+y+zの型が同一になってしまう。
なので、この場合は新しい型変数を割り当てる。
具体的には、型変数を単一化せずに使う場合、戻り値型は新しく発行する。
この場合、`+`('1, '2) == '5とする。
`+`(`+`('1, '2), '3)についても同様に、`+`(`+`('1, '2), '3) == '6である。
最終的な戻り値の'6は'4に単一化する。
最後に型境界の処理を行う。'4型がどのような条件で与えられる型なのか明示する必要があるのである。
結論から言うと以下のようになる。

```erg
f: |'1 <: {`+` = Self.'2 -> '5}, '5 <: {`+` = Self.'3 -> '4}| ('1, '2, '3) -> '4
f x, y, z = x + y + z
```

この型境界により'4の型が決定される。
このように見ると全てのサブルーチンが型推論可能なように思えるかもしれないが、残念ながらそうはいかない。
推論ができない例としては、再帰関数がある。

```erg
fib 0 = 0
fib 1 = 1
fib n = fib(n-1) + fib(n-2)
```

先ほどと同じようにすると、型境界は以下のようになる。

```erg
fib: |
    '1: -{0, 1}
    '1 <: {`-` = ('Self, {1}) -> '3}
    '1 <: {`-` = ('Self, {2}) -> '4}
    '5 == <fib> '3,
    '6 == <fib> '4,
    '5 <: {`+` = (Self, '6) -> '2}
| '1 -> '2
fib n = fib(n-1) + fib(n-2)
```

試しにNatを代入してみる。

```erg
fib: |
    {`-` = (Nat-{0, 1}, {1}) -> 1.._}
    {`-` = (Nat-{0, 1}, {2}) -> 0.._}
    {fib = {1} -> {1}}
    {fib = {0} -> {0}}
    {fib = 1.._ -> ?}
    {fib = 0.._ -> ?}
    {`+` = ?, ? -> ?}
| Nat -> ?
```

```erg
fib: |
    {`-` = (1.._).{1} -> 0.._}
    {`-` = (1.._).{2} -> -1.._}
    {fib = 0.._ -> ?} # fib Natに戻ってしまう!
    {fib = -1.._ -> ?}
    {`+` = ?.? -> ?}
| 1.._ -> ?
```

こういうわけで、型推論が無限ループしてしまう。
よって、再帰関数は戻り値の指定が必須である(Haskell等の言語ではリテラルから型を推論するが、Ergは依存型を持つのでリテラルの型が一意に決まらない)。
これは相互再帰関数の場合もだが、どれか一つを型指定するだけでよい。

```erg
odd 0 = False
odd(n): Bool = even n-1
even 0 = True
even n = odd n-1
```

```erg
odd:|
    '1 <: Not {0}
    {`-` = '1, {1} -> '2}
    {even = '2 -> Bool} # 推論ではなく強制
| '1 -> Bool
odd n = even n-1

even: |
    '1 <: Not {0}
    {`-` = '1, {1} -> '2}
    {odd = '2 -> Bool}
| '1 -> Bool
even n = odd n-1
```

しかし、この型付けには問題がある。減算が定義されている数なら何でも受け付けてしまうのである。
つまり、`odd -1`が型検査を通ってしまう。これは明らかにナンセンスで、永遠に計算結果は現れない。
この場合は`odd(n: Nat): Bool = even n-1`と、引数の型も明示しておくべきである。
こうすれば`even`の方もナンセンスな引数は受け付けない。
