# 型推論

> __Warning__： この文書の情報は古く、一部に間違いを含みます。

Ergでは多くの場合引数の型を省略することが可能である。
内部的には、省略された引数は型変数で型付けされる。つまり、なんでも受け入れる型である。
そこから、関数内部での使われ方に応じて最小の型制約が課される。
多くの場合、型推論によってシグネチャから型変数がすべて除去されることはない。
例えば、`x + 1`と書かれていたとき、`x`は`'0`型で、その制約は'0 <: `+`({1}, '1)である。
ほかの言語、例えばOCamlではこの時点でxはIntと決定されてしまうが、ErgではNat, Int, Float, ...あるいはユーザー定義のクラス・型などが入る可能性もある。よって、この定義の時点では単に'0と置くだけで、戻り値型の推論は使用時に行われる。
Ergでは再帰関数の定義も可能であるが、現在のところ、技術的な理由で再帰関数の戻り値は推論されない。推論が不可能な場合が多いからである。

```erg
fib 0 = 0
fib 1 = 1
fib n: Nat = fib(n-1) + fib(n-2)
```

上記の`fib`の定義は、

```erg
fib n: Nat =
    match x:
        0 -> 0
        1 -> 1
        n -> fib(n-1) + fib(n-2)
```

と同じである。

## 型推論の例

```erg
fib 0 = 0
fib 1 = 1
fib n: Nat = fib(n-1) + fib(n-2)

# 相互再帰関数も定義可能
even 0 = True
even n: 1.. = odd n-1
odd 0 = False
odd n: 1.. = even n-1

sig _: Neg = -1
sig 0 = 0
sig _: Pos = 1

f 1 = 0
f 2 = 1
f(x): Nat = f x*2
```

これらの関数の推論は以下のように行われる。
ただし、以下の記法を使用する。

* `f x: T`なる関数があったとき、`f`の戻り値の型を`f T`と表す。すなわち、`f: T -> U`のとき`U = f T`である。
* `∴`は「故に」「よって」を表す。
* minはその型を実現する最小の単相型を表す。
  `'T`に制約がないとき、`min('T) = Never`
  `T`が単相型のとき、`min(T) = T`

## fib

* fib 0とfib 1に関しては直接型付け可能。
  fib: {0} -> {0}
  fib: {1} -> {1}
  fib: {0, 1} -> {0, 1} (この関数は宣言だけ登録され、実体は使用されるまで生成されない。実体はmatchによって生成される)
* fib: 2.. -> '0 | '0 <: min(fib 2.. - {1} + fib 2.. - {2})
  fib: 2.. -> '0 | '0 <: min(fib 1.. + fib 0..)
* fib: 1.. -> '1とfib 0.. -> '2の型推論を行う(実際は新しい名前空間で推論するので'1, '2にインクリメントする必要はないが、見やすさのためにこうしている)
  * fib: 1.. -> '1について、既に存在する宣言から順に決め打ちする
    * fib {1} -> {1}が見つかったので、1..から{1}を抜く->2..
    * fib 2.. -> '0が見つかったので、2..から2..を抜く->Never
    * Neverになったので完成、fib: 1.. -> {1} or '0
  * fib: 0.. -> '2についても同様にしてfib: 0.. -> {0, 1} or '0
* fib: 2.. -> '0 | '0 <: min(({1} or '0) + ({0, 1} or '0))
  再帰型の推論では「任意回の操作によって得られる型(see erg_type_inferring_recursive.md)」を計算する
  つまり、'0は{1}と{0, 1}の任意回の加算によって生成される型である
  {0}+{0}以外の正数集合の任意回可算はNatを生成する
* 合計で宣言されたのは
  fib: {0} -> {0}
  fib: {1} -> {1}
  fib: {0, 1} -> {0, 1}
  fib: 2.. -> Nat
  fib: {0} or 2.. -> Nat
  fib: 1.. -> Nat
  fib: Nat -> Nat
  の7種類。

## even, odd

* even 0とodd 0に関しては直接型付け可能。
  even.{0} \_ = True
  odd.{0} \_ = False
* even nとodd nの戻り値型を'0, '1としておく。
  even: 1.. -> '0 | '0 <: odd 1.. - 1
  ∴ even: 1.. -> '0 | '0 <: odd 0..
    odd 0..:
      odd {0} -> {False}
      odd 1.. -> '1
  ∴ even: 1.. -> '0 | '0 <: {False} or '1
  odd: 1.. -> '1 | '1 <: even 1.. -1
  ∴ odd: 1.. -> '1 | '1 <: even 0..
    even 0..:
      even {0} -> {True}
      even 1.. -> '0 | '0 <: {False} or '1
  odd:  1.. -> '1 | '1 <: {True, False} or '1
  odd: 1.. -> {True, False}
  even: 1.. -> {True, False}
* 合計で宣言されたのは
  even: {0} -> {True}
  odd: {0} -> {False}
  odd: 1.. -> Bool
  even: 1.. -> Bool
  even: Nat -> Bool
  odd: Nat -> Bool

## sig

* sig _: ..=-1 = -1より
  sig.(..0) \_ = -1
  が定義される。一意性のため、x: Natのとき..=xは..x+1に置換される(Floatでは置換できない)。
* sig 0 = 0より内部で
  sig.{0} \_ = 0
  sig.(..0) \_0 =
      match _0:
        _1: ..0 -> sig.(..0) _1
        _1: {0} -> sig.{0} _1
  が定義される。
* sig: _: 1.. = 1より
  sig.(1..) \_ = 1
  (..=-1 or 1..) <.> NZInt
  sig.NZInt \_0 =
      match \_0:
        _1: ..0 -> sig.(..0) _1
        _1: 1.. -> sig.(1..) _1
  (..=-1 or 0 or 1..) <.> Int
  sig.Int \_0 =
      match \_0:
        _1: ..0 -> sig.(..0) _1
        _1: {0} -> sig.{0} _1
        _1: 1.. -> sig.(1..) _1
  が定義される。

## f

* まず宣言されるのは以下の通り。
  f: {1} -> {0}
  f: {2} -> {1}
  f: {1, 2} -> {0, 1}
  f: {"a"} -> {2}
  f: {1, "a"} -> {0, 2}
  f: {2, "a"} -> {1, 2}
  f: {1, 2, "a"} -> {0, 1, 2}
* f: '0 -> '1 | '1 <: f '0 * {2}, Mul('0, {2}, '2)
* '2を決め打つ
  * '2 <: {1}とすると、Mul '0, {2}, {1}より'0 <: {0.5}
    f: {0.5} -> {0}
  * '2 <: {2}とすると、Mul '0, {2}, {2}より'0 <: {1}
    f: {1} -> {1}だが、これはf: {1} -> {0}に矛盾、型エラー
  * '2 <: {"a"}とすると、Mul '0, {2}, {"a"}を満たす解は存在しない
  * '2を型変数のままにする('2 != {1, 2, "a"})と、'2 <: '0
    f: '0 -> '1 | Mul('0, {2}, '0)
    '1の制約がないので、推論不能
