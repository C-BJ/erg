# 再帰型の型推論

再帰型の型推論では、任意回の呼び出しで生成されるオブジェクトの集合を計算することとなる。
これは実質的には無限回の操作で生成される空間と同義である。
`fn T`をサブルーチン`fn`に対する`T`型オブジェクトの適用による戻り値型とするとき、関数呼び出しをn回行って導出される型をfn^n Tと表す。つまり、fn(fn(...(fn(T)))) == fn^n Tである。
複数引数の場合、前の呼び出しの結果が第1引数となる場合、つまりfn(fn(fn(fn(x, y_1)..., y_n-2) y_n-1) y_n)はfn^n X Y^nと表す。
同様に、前の呼び出しの結果が第2引数となる場合、つまりfn(x_1 fn(x_2 ...fn(x_n y)))はfn^n X^n Yまたは(fn X)^n Yと表す。
例としては階乗関数`fact n: Nat = n * fact n-1`がある。`fact: 1.. * fact (1.. - {1}) == (1.. *)^n {1}`である。

再帰型ではいくらでも呼び出しうるため、関数の戻り値に使われている関数fnの無眼回適用で生成されるfn^∞ Tが戻り値型である。
現在実装されている推論規則は以下の通り。

指定のない限り、x, y, z: Nat

* id^∞ t == {t}
* ({0} +)^∞ x..y == x..y
* ({0} -)^∞ x..y = -y..-x
* ({1} *)^∞ x..y == x..y
* ({z} +)^∞ x..y == Nat
* ({z} -)^∞ x..y = Int
* ({""} +)^∞ {s} == {s}
* ({s = Str len = 1..} +)^∞ {\_ = Str} == Str

## 非依存化

Independizationは依存型を一般の型に戻す操作である。例として、{1} -> Natなどがある。
普通のダウンキャストの場合は、{1} -> {0, 1} -> {0, 1, 2}などとなる場合がある。これはその名前空間で定義のある依存型による。
依存型は無限にあるため、定義のあるものにしかダウンキャストしないのである。
しかしIndependizationは一意的である。
非依存化は依存型の推論が失敗した場合に行われる。
{1, True}など、別々のクラスに属するオブジェクト同士の非依存化は失敗(コンパイルエラー)する。
{-1, 0, 1}など同一のクラスであれば成功する。その際、クラスは可能な限り子クラスになる(この場合はInt)。
型変数を含んだ型、例えば{True} or '0は、型変数を含まない方が非依存化されたあと消去される(この場合はBool)。
もともとErgのランタイムにはクラスしか存在しないので、この操作は型消去の一種であり、情報は失われるが健全性が壊れることはない(TODO:証明を与える)。

## 依存推論のテスト

```erg
func 0, 0, _ = True
func 0, _, _ = False
func(i, x, a) =
    # a[i-1] を選ばない場合 (func(i-1, x, a) が OK なら OK)
    if func(i-1, x, a):
        return True
    # a[i-1] を選ぶ場合 (func(i-1, x-a[i-1], a) が OK なら OK)
    if func(i-1, x-a[i-1], a):
        return True

    False
```
