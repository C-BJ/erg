# 類型推理算法

> ：本節正在編輯中，可能包含某些錯誤。

以下是使用的表示方法。


```erg
自由類型變量（類型，未綁定）：?T, ?U,...
自由類型變量（值，未綁定）：?a, ?b,...
輸入環境 (Γ): { x: T,... }
類型分配規則 (S): { ?T --> T,...}
類型參數評估環境 (E): { e -> e',...}
```

下面的代碼是一個示例。


```erg
v = ![]
v.push! 1
print! v
```

Erg 類型推理的主要框架是 Hindley-Milner 類型推理算法（但進行了各種擴展）。具體來說，類型推論是按照以下步驟進行的。術語描述將在後面介紹。

1. 推斷右邊值的類型（search）
2. 使得到的類型具體化（instantiate）
3. 調用時進行類型賦值（substitute）
4. 體現單相特寫（resolve traits）
5. 求值和簡化類型變量值（eval）
6. 刪除鏈接的類型變量（deref）
7. 對於可變依賴方法，傳播更改（propagate）
8. 如果左側值存在且可調用，則執行參數類型的一般化（generalize）
9. 如果有左側值，則（返回值）類型一般化（generalize）
10. 如果賦值，則在符號表（）中登記類型信息（update）。

具體操作如下。

line 1. Def{sig: v, block: ![]}
    get block type:
        get UnaryOp type:
            get Array type: `['T; 0]`instantiate: `[?T; 0]`(substitute, eval are omitted)
    update: `Γ: {v: [?T; 0]!}`expr returns `NoneType`: OK

line 2. CallMethod{obj: v, name: push!, args: [1]}
    get obj type: `Array!(?T, 0)`
        search: `Γ Array!(?T, 0).push!({1})`get: `= Array!('T ~> 'T, 'N ~> 'N+1).push!('T) => NoneType`instantiate: `Array!(?T, ?N).push!(?T) => NoneType`substitute(`S: {?T --> Nat, ?N --> 0}`): `Array!(Nat ~> Nat, 0 ~> 0+1).push!(Nat) => NoneType`eval: `Array!(Nat, 0 ~> 1).push!({1}) => NoneType`update: `Γ: {v: [Nat; 1]!}`
    expr returns `NoneType`: OK

line 3. Call{obj: print!, args: [v]}
    get args type: `[[Nat; 1]!]`get obj type:
        search: `Γ print!([Nat; 1]!)`get: `= print!(...Object) => NoneType`
    expr returns `NoneType`: OK

## 實現類型變量

類型變量最初在的<gtr=“43”/>中表示如下。雖然現在以不同的形式實現，但本質上是相同的想法，所以我用更簡單的表達方式——這個實現來思考。 <gtr=“44”/>是<gtr=“45”/>的包裝類型。


```rust
pub enum Type {
    ...
    Var(RcCell<Option<Type>>), // a reference to the type of other expression, see docs/compiler/inference.md
    ...
}
```

類型變量可以實現在外部字典中具有實體類型，而類型變量本身僅具有該鍵。然而，使用實現通常更有效（需要驗證，<gtr=“48”/>）。

類型變量首先按進行初始化。此類型變量在代碼分析過程中被重寫，以確定類型。如果內容始終為 None，則會產生一個類型變量，不能（立即）確定為特定類型。例如，<gtr=“50”/>的<gtr=“51”/>類型。我們將這種狀態下的類型變量稱為<gtr=“52”/>（確切術語未知）。與此相對，如果指定了某種特定類型，則稱為<gtr=“53”/>。

這兩種類型都是自由變量（很明顯，我們認為這一術語是根據“自由變量”命名的）。這些是編譯器用於推理的類型變量。這是因為它與程序員指定的類型變量不同，例如中的<gtr=“55”/>。

未綁定變量應表示為和<gtr=“57”/>。在型理論的上下文中使用α和β的情況比較多，但是為了輸入的簡便化，採用了這個。請注意，這是一種用於一般討論的符號，實際上並不是使用字符串標識符實現的。

當未綁定的變量被置於類型環境中時，它被替換為<gtr=“59”/>。這就是我們所說的<gtr=“61”/>。它類似於程序員指定的類型變量，如<gtr=“60”/>。它的內容只是一個字符串，不像自由變量那樣可以鏈接到特定類型。

將未綁定變量替換為量化變量的操作稱為（或泛化）。如果仍然是未綁定的變量，則必須在一次調用中固定類型（例如，在<gtr=“62”/>調用後，<gtr=“63”/>的返回類型變為<gtr=“64”/>），因此必須將其一般化。這樣，將在類型環境中註冊包含量化變量的廣義定義。

## 一般化、類型方案、具體化

將未綁定變量一般化的操作表示為<gtr=“67”/>。假設得到的廣義變量為<gtr=“68”/>。在類型理論中，量化類型（例如，多相關數類型<gtr=“69”/>）通過在其前面加上<gtr=“70”/>來進行區分（例如，大塊等符號稱為（全稱）量化器）。這種表達式（e.g.<gtr=“71”/>）稱為類型方案。 Erg 中的類型方案表示為<gtr=“72”/>等。類型方案通常不被視為一級類型。這樣配置類型系統可能會導致類型推理無法正常工作。然而，在某些情況下，Erg 被視為主要類型。有關詳細信息，請參見<gtr=“73”/>。

現在，當在類型推理中使用得到的類型方案（e.g.）時，必須取消一般化（e.g.<gtr=“75”/>，<gtr=“76”/>）。這種反變換稱為<gtr=“78”/>。我們將此操作稱為<gtr=“77”/>。


```erg
gen ?T = 'T
inst 'T = ?T (?T ∉ Γ)
```

重要的是，這兩個操作都會替換該類型變量出現的所有位置。例如，如果將具體化，則得到<gtr=“80”/>。在實現過程中，需要 Dict 來替換它，但在一般化過程中，只需將<gtr=“81”/>鏈接到<gtr=“82”/>即可替換它。

然後給出參數的類型，得到所需的類型。我們將此操作稱為類型賦值（Type substitution），並將其表示為。此外，<gtr=“84”/>表示當表達式是調用時獲得返回類型的操作。第一個參數是參數類型列表，第二個參數是目標類型。

類型賦值規則表示將<gtr=“86”/>和<gtr=“87”/>重寫為同一類型。此操作稱為<gtr=“91”/>。 <gtr=“88”/>也可以是類型變量。關於單一化的詳細算法，請參見<gtr=“90”/>。單一化操作應表示為<gtr=“89”/>。


```erg
unify(?T, Int) == Ok(()) # ?T == (Int)

# Sは型代入規則、Tは適用する型
subst(S: {?T --> X}, T: ?T -> ?T) == X -> X
# 型代入規則は{?T --> X, ?U --> T}
subst_call_ret([X, Y], (?T, ?U) -> ?U) == Y
```

## 半單一化

單一化的一個亞種是半單一化（__Semi-unification__）。這是更新類型變量約束以滿足子類型關係的操作。在某些情況下，類型變量可以是單一變量，也可以是不單一變量，因此稱為“半”單一變量。

例如，在賦值參數時會發生半單一化。實際參數類型必須是虛擬參數類型的子類型。如果參數的類型是類型變量，則必須更新子類型關係以滿足該類型。


```erg
# 仮引數の型をTとすると
f(x: T): T = ...

a: U
# U <: Tでなくてはならない、さもなければ型エラー
f(a)
```

## 一般化

一般化不是一項簡單的工作。如果涉及多個範圍，就需要對類型變量進行“級別管理”。為了了解等級管理的必要性，首先確認不引入等級管理的類型推理會產生問題。試著推論以下無名函數的類型。


```erg
x ->
    y = x
    y
```

首先，Erg 分配類型變量，如下所示。 y 的類型也是未知的，但現階段不指定它。


```erg
x(: ?T) ->
    y = x
    y
```

首先要確定的是右邊值 x 的類型。右邊的值是“使用”，因此它是具體化的。但是，x 的類型是一個自由變量，因此已經被具體化。因此，<gtr=“93”/>仍然是右邊值的類型。


```erg
x(: ?T) ->
    y = x (: inst ?T)
    y
```

在註冊為類型 y 的左側值時進行一般化。但是，稍後將會發現，這種一般化是不完整的，結果是錯誤的。


```erg
x(: ?T) ->
    y(: gen ?T) = x (: ?T)
    y
```


```erg
x(: ?T) ->
    y(: 'T) = x
    y
```

y 的類型現在是量化變量。在下一行中，<gtr=“95”/>被立即使用。具體化。


```erg
x: ?T ->
    y(: 'T) = x
    y(: inst 'T)
```

需要注意的是，在實現過程中，必須生成與任何已存在的（自由）類型變量不同的（自由）類型變量（一般化也是如此）。這些類型變量稱為新鮮類型變量。


```erg
x: ?T ->
    y = x
    y(: ?U)
```

然後看得到的整個公式的類型。 。但很明顯，這個公式應該是，你會發現推理有問題。之所以會這樣，是因為我們沒有對類型變量進行“級別管理”。

因此，使用以下符號引入類型變量的級別。級別以自然數表示。


```erg
# 通常のType型変數
?T<1>, ?T<2>, ...
# 部分型製約を付けられた型変數
?T<1>(<: U) or ?T(<: U)<1>, ...
```

現在，我再試一次。


```erg
x ->
    y = x
    y
```

首先，按如下所示賦值級別變量。頂級級別為 1. 範圍越深，等級就越高。函數的參數屬於內部範圍，因此它位於比函數本身大一個級別。


```erg
# level 1
x (: ?T<2>) ->
    # level 2
    y = x
    y
```

首先，將右邊值具體化。和剛才一樣，什麼都不會改變。


```erg
x (: ?T<2>) ->
    y = x (: inst ?T<2>)
    y
```

從這裡開始就是基莫。這是分配給類型左邊值時的一般化。剛才這裡的結果很奇怪，所以我們要改變廣義算法。如果類型變量的級別小於或等於當前範圍的級別，則一般化後將保持不變。


```erg
gen ?T<n> = if n <= current_level, then= ?T<n>, else= 'T
```


```erg
x (:?T<2>) ->
    # current_level = 2
    y (: gen ?T<2>)  = x (: ?T<2>)
    y
```

也就是說，左邊值的類型為<gtr=“101”/>。


```erg
x (: ?T<2>) ->
    #    ↓ not generalized
    y (: ?T<2>)  = x
    y
```

y 的類型現在為未綁定變量。在下一行中進行說明。但是，<gtr=“103”/>類型並不通用，因此不會發生任何情況。


```erg
x (: ?T<2>) ->
    y (: ?T<2>) = x
    y (: inst ?T<2>)
```


```erg
x (: ?T<2>) ->
    y = x
    y (: ?T<2>)
```

成功地得到了正確的類型。

我再看一個例子。這是更常見的情況，函數，運算符應用，前向參照。


```erg
f x, y = id(x) + y
id x = x

f 10, 1
```

讓我們一條一條地看。

在推論中，引用了後面定義的函數常量<gtr=“106”/>。在這種情況下，可以在<gtr=“107”/>之前插入一個聲明<gtr=“108”/>，並分配一個自由變量。請注意，此時類型變量的級別為。這是為了避免在其他函數中被一般化。


```erg
id: ?T<1> -> ?U<1>
f x (: ?V<2>), y (: ?W<2>) =
    id(x) (: subst_call_ret([inst ?V<2>], inst ?T<1> -> ?U<1>)) + y
```

類型變量之間的統一會將較高級別的類型變量替換為較低級別的類型變量。如果級別相同，這兩個級別都可以。

類型變量之間的半單一化，情況稍有不同。對於不同級別的類型變量，不能相互施加類型約束。


```erg
# BAD
f x (: ?V<2>), y (: ?W<2>) =
    # ?V<2>(<: ?T<1>)
    # ?T<1>(:> ?V<2>)
    id(x) (: ?U<1>) + y (: ?W<2>)
```

這樣，你就無法確定類型變量的具體體現位置。對於 Type 類型變量，請執行常規的單一化，而不是半單一化。也就是說，讓他們單一化到低級別。


```erg
# OK
f x (: ?V<2>), y (: ?W<2>) =
    # ?V<2> --> ?T<1>
    id(x) (: ?U<1>) + y (: ?W<2>)
```


```erg
f x (: ?T<1>), y (: ?W<2>) =
    (id(x) + x): subst_call_ret([inst ?U<1>, inst ?W<2>], inst |'L <: Add('R)| ('L, 'R) -> 'L.AddO)
```


```erg
f x (: ?T<1>), y (: ?W<2>) =
    (id(x) + x): subst_call_ret([inst ?U<1>, inst ?W<2>], (?L(<: Add(?R<2>))<2>, ?R<2>) -> ?L<2>.AddO)
```


```erg
id: ?T<1> -> ?U<1>
f x (: ?T<1>), y (: ?W<2>) =
    # ?U<1>(<: Add(?W<2>)) # 繼承 ?L 的約束
    # ?L<2> --> ?U<1>
    # ?R<2> --> ?W<2> (?R(:> ?W), ?W(<: ?R)とはしない)
    (id(x) + x) (: ?U<1>.AddO)
```


```erg
# current_level = 1
f(x, y) (: gen ?T<1>, gen ?W<2> -> gen ?U<1>.AddO) =
    id(x) + x
```


```erg
id: ?T<1> -> ?U<1>
f(x, y) (: |'W: Type| (?T<1>, 'W) -> gen ?U<1>(<: Add(?W<2>)).AddO) =
    id(x) + x
```


```erg
f(x, y) (: |'W: Type| (?T<1>, 'W) -> ?U<1>(<: Add(?W<2>)).AddO) =
    id(x) + x
```

在定義時進行升級以使其一般化。


```erg
# ?T<1 -> 2>
# ?U<1 -> 2>
id x (: ?T<2>) -> ?U<2> = x (: inst ?T<2>)
```

如果已分配返回類型，則將返回類型與返回類型合併（）。


```erg
# ?U<2> --> ?T<2>
f(x, y) (: |'W: Type| (?T<2>, 'W) -> ?T<2>(<: Add(?W<2>)).AddO) =
    id(x) + x
# current_level = 1
id(x) (: gen ?T<2> -> gen ?T<2>) = x (: ?T<2>)
```

如果一個類型變量只是一個類型變量，則它所依賴的類型變量也是一個類型變量。一般化類型變量在每個函數中都是獨立的。


```erg
f(x, y) (: |'W: Type, 'T <: Add('W)| ('T, 'W) -> 'T.AddO) =
    id(x) + x
id(x) (: |'T: Type| 'T -> gen 'T) = x
```


```erg
f x, y (: |'W: Type, 'T <: Add('W)| ('T, 'W) -> 'T.AddO) =
    id(x) + y
id(x) (: 'T -> 'T) = x

f(10, 1) (: subst_call_ret([inst {10}, inst {1}], inst |'W: Type, 'T <: Add('W)| ('T, 'W) -> 'T.AddO)
```


```erg
f(10, 1) (: subst_call_ret([inst {10}, inst {1}], (?T<1>(<: Add(?W<1>)), ?W<1>) -> ?T<1>.AddO))
```

類型變量將擴展到其實現的最小類型。


```erg
# ?T(:> {10} <: Add(?W<1>))<1>
# ?W(:> {1})<1>
# ?W(:> {1})<1> <: ?T<1> (:> {10}, <: Add(?W(:> {1})<1>))
# 序列化
# {1} <: ?W<1> or {10} <: ?T<1> <: Add({1}) <: Add(?W<1>)
# Add(?W)(:> ?V) 的最小實現特徵是 Add(Nat) == Nat，因為 Add 相對於第一個參數是協變的
# {10} <: ?W<1> or {1} <: ?T<1> <: Add(?W<1>) <: Add(Nat) == Nat
# ?T(:> ?W(:> {10}) or {1}, <: Nat).AddO == Nat # 如果只有一個候選人，則固定評分
f(10, 1) (: (?W(:> {10}, <: Nat), ?W(:> {1})) -> Nat)
# 程序到此結束，所以去掉類型變量
f(10, 1) (: ({10}, {1}) -> Nat)
```

因此，整個程序的類型是這樣的。


```erg
f|W: Type, T <: Add(W)|(x: T, y: W): T.AddO = id(x) + y
id|T: Type|(x: T): T = x

f(10, 1): Nat
```

重新提示原始未顯式輸入的程序。


```erg
f x, y = id(x) + y
id x = x

f(10, 1)
```