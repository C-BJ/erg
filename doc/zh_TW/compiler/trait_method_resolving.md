# 解決修補程序方法

是大於 0 的<gtr=“9”/>，即<gtr=“10”/>的子類型。本來不存在於 Python 的類階層中。 Erg 如何解決這個補丁的方法呢？


```erg
1.times do:
    log "hello, world"
```

是<gtr=“13”/>的補丁方法。由於<gtr=“14”/>是<gtr=“15”/>的實例，所以首先要沿著<gtr=“16”/>的 MRO（方法解析順序）進行搜索。 Erg 在<gtr=“17”/>的 MRO 中有<gtr=“18”/>，<gtr=“19”/>。它來自 Python（在 Python 中<gtr=“20”/>）。 <gtr=“21”/>方法在這兩個方法中都不存在。從這裡開始，進入該子類型的探索。

~

整數在其上位型中顯然應該具有實數和復數，甚至是整體數，但在與 Python 具有互換性的層中卻不出現這一事實。但是實際上在 Erg 中，和<gtr=“23”/>是<gtr=“24”/>。至於<gtr=“25”/>，雖然是與<gtr=“26”/>沒有繼承關係的類，但作為類型被判斷為具有互換性。究竟是怎麼回事？

~

對於某個對象，其所屬的類型有無數個。但是實際上必須考慮的是擁有方法的類型，即只有擁有名字的類型。

Erg 編譯器擁有所有提供方法及其安裝的補丁型散列映射。每次新定義類型時，此表都會更新。


```erg
provided_method_table = {
    ...
    "foo": [Foo],
    ...
    ".times": [Nat, Foo],
    ...
}
```

具有方法的類型為<gtr=“28”/>，<gtr=“29”/>。從這些中，尋找符合型的。符合判定有兩種。篩型判定和記錄型判定。從篩型判定開始進行。

## 篩子型判定

檢查候選類型是否與類型<gtr=“32”/>兼容。篩型中與<gtr=“33”/>兼容的有<gtr=“34”/>，<gtr=“35”/>等。 <gtr=“36”/>，<gtr=“37”/>等有限元的代數運算類型，如果聲明為基本類型，則被歸一化為篩子類型（即，<gtr=“38”/>，<gtr=“39”/>）。在這次的情況下，由於<gtr=“40”/>是<gtr=“41”/>，所以<gtr=“42”/>與<gtr=“43”/>是兼容的。

## 記錄類型判定

確認是否與候選類型為 1 的類兼容。此外，當<gtr=“45”/>的補丁，並且<gtr=“46”/>具有所有的要求屬性時，也具有兼容性。

~

因此，是合適的。但是，當<gtr=“48”/>也符合時，根據<gtr=“49”/>和<gtr=“50”/>的包含關係進行判定。也就是說，選擇子類型的方法。如果兩者沒有包含關係，則會出現編譯錯誤（這是一種安全措施，可防止執行與程序員意圖相反的方法）。為了消除錯誤，必須明確指定修補程序。


```erg
o.method(x) -> P.method(o, x)
```

## 全稱補丁程序方法解析

定義如下補丁。


```erg
FnType T: Type = Patch T -> T
FnType.type = T
```

在補丁的基礎上可以進行以下代碼。這又將如何解決呢？


```erg
assert (Int -> Int).type == Int
```

首先，中<gtr=“53”/>以以下形式登錄。


```erg
provided_method_table = {
    ...
    "type": [FnType(T)],
    ...
}
```

檢查是否符合的補丁類型。此時，<gtr=“55”/>的補丁類型為<gtr=“56”/>。這符合<gtr=“57”/>。匹配後，進行單相化置換（取<gtr=“58”/>和<gtr=“59”/>的 diff。<gtr=“60”/>）。


```erg
assert FnType(Int).type == Int
```