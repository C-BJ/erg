# Comprehension

你可以用創建數組，用<gtr=“7”/>創建集，用<gtr=“8”/>創建 Dict。

用分隔的節中，最初的部分稱為佈局節（配置節），第 2 部分稱為綁定節（綁定節），第 3 部分稱為保護節（條件節）。保護子句是可選的，但不能省略綁定子句，並且保護子句不能位於綁定子句之前。

內包表示法示例


```erg
# 佈局子句是 i
# 綁定子句是 i <- [0, 1, 2]
assert [i | i <- [0, 1, 2]] == [0, 1, 2]

# 佈局子句是 i / 2
# 綁定子句是 i <- 0..2
assert [i / 2 | i <- 0..2] == [0.0, 0.5, 1.0]

# 佈局子句是 (i, j)
# 綁定子句 i <- 0..2, j <- 0..2
# 保護子句是 (i + j) % 2 == 0
assert [(i, j) | i <- 0..2; j <- 0..2; (i + j) % 2 == 0] == [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)]

assert {i % 2 | i <- 0..9} == {0, 1}
assert {k: v | k <- ["a", "b"]; v <- [1, 2]} == {"a": 1, "b": 2}
```

Erg 的內涵表述受到 Haskell 的影響，但略有差異。對於 Haskell 的列表內涵表示法，變量的順序會導致結果的差異，而對於 Erg 則沒有關係。


```haskell
-- Haskell
[(i, j) | i <- [1..3], j <- [3..5]] == [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
[(i, j) | j <- [3..5], i <- [1..3]] == [(1,3),(2,3),(3,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
```


```erg
# Erg
assert [(i, j) | i <- 1..<3; j <- 3..<5] == [(i, j) | j <- 3..<5; i <- 1..<3]
```

這個規格和 Python 的一樣。


```python
# Python
assert [(i, j) for i in range(1, 3) for j in range(3, 5)] == [(i, j) for j in range(3, 5) for i in range(1, 3)]
```

## 篩子型

與內涵表記相似的還有篩子型。篩子類型是以的形式創建的類型（枚舉類型）。對於篩子類型，名稱只能是一個，不能指定佈局（但可以處理多個值，例如元組類型），而 Predicate 只能是編譯時計算的常量表達式。


```erg
Nat = {I: Int | I >= 0}
# 如果謂詞表達式只有and，可以替換為：
# Nat2D = {(I, J): (Int, Int) | I >= 0; J >= 0}
Nat2D = {(I, J): (Int, Int) | I >= 0 and J >= 0}
```

<p align='center'>
    <a href='./26_pattern_matching.md'>Previous</a> | <a href='./28_spread_syntax.md'>Next</a>
</p>