# 類型擦除（Type erasure）

類型擦除是指將指定為類型參數，並故意丟棄該信息。類型擦除是許多具有多相類型的語言的一個功能，但根據 Erg 語法，類型自變量擦除可能更準確。

最常見的類型清除類型的示例可能是。在編譯數組時，你可能不知道數組的長度。例如，指向命令行參數的<gtr=“8”/>類型為<gtr=“9”/>。 Erg 編譯器不知道命令行參數的長度，因此必須放棄關於長度的信息。但是，由於已擦除的類型成為未擦除類型的超類型（e.g.<gtr=“10”/>），因此可以接收更多對象。 <gtr=“11”/>類型的對象當然可以使用<gtr=“12”/>類型的方法，但使用後<gtr=“13”/>信息將被清除。因為長度可能已經改變了。如果長度不變，則必須用簽名表示。


```erg
# 配列の長さが変わらないことが保証される関數(sortなど)
f: [T; N] -> [T; N]
# されない関數(filterなど)
g: [T; n] -> [T; _]
```

如果類型本身使用，則該類型將上傳至<gtr=“15”/>。對於非類型的類型參數（例如，Int 和 Bool 類型），<gtr=“16”/>是未定義的參數。


```erg
i: _ # i: Object
[_; _] == [Object; _] == Array
```

類型擦除不同於類型省略。一旦清除了類型參數信息，則必須再次斷言才能返回該信息。


```erg
implicit = (1..5).iter().map(i -> i * 2).to_arr()
explicit = (1..5).iter().map(i -> i * 2).into(Array(Nat))
```

Rust 支持以下代碼。


```rust
let partial = (1..6).iter().map(|i| i * 2).collect::<Vec<_>>();
```

Erg 不能部分省略類型，而是使用高階卡印多相。


```erg
# collect 是一個接收 kind 的高階 kind 方法
hk = (1..5).iter().map(i -> i * 2).collect(Array)
hk: Array(Int)
```