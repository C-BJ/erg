# 存在類型

如果有對應於應有盡有的全稱型，那麼自然會有對應於應有盡有的存在型。存在型並不難。只是你沒有這樣的意識，就已經知道了你的存在型。


```erg
T: Trait
f x: T = ...
```

上面的trait被用作存在類型。相反，下面的<gtr=“6”/>只是trait，<gtr=“7”/>是全稱類型。


```erg
f|X <: T| x: X = ...
```

事實上，存在類型被全稱類型所取代。那麼為什麼會存在所謂的存在型呢？首先，正如上面所見，存在類型不涉及類型變量，因此可以簡化類型指定。此外，由於可以移除類型變量，因此可以配置全稱類型，使其超過等級 2。


```erg
show_map f: (|T| T -> T), arr: [Show; _] =
    arr.map x ->
        y = f x
        log y
        y
```

但是，一看就知道，存在型會忘卻、擴大原來的型，所以不想擴大返回值的型等情況下，需要使用全稱型。相反，只作為參數接收而與返回值無關的類型可以用存在類型來描述。


```erg
# id(1): 我希望它是一個 Int
id|T|(x: T): T = x
# |S <: Show|(s: S) -> () 是多餘的
show(s: Show): () = log s
```

順便說一下，類不稱為存在類型。因為預先決定了成為那個要素的對象。存在型是指滿足某一trait的所有類型，實際上不知道要代入什麼類型。