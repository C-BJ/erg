# 可變類型（Mutable Type）

> ：本節中的信息過時，並且包含一些錯誤。

缺省情況下，Erg 將所有類型設置為不可變類型，即不能更新內部狀態。但你當然可以定義可變類型。變量類型聲明為。


```erg
Person! = Class({name = Str; age = Nat!})
Person!.
    greet! ref! self = print! "Hello, my name is {self::name}. I am {self::age}."
    inc_age! ref! self = self::name.update! old -> old + 1
```

確切地說，以可變類型或包含可變類型的複雜類型為基本類型的類型必須在類型名稱後加上。沒有<gtr=“17”/>的類型也可以存在於同一命名空間中，並被視為不同的類型。在上面的示例中，<gtr=“18”/>屬性是可變的，而<gtr=“19”/>屬性是不變的。如果有一個屬性是可變的，則整個屬性都是可變的。

變量類型可以定義用於重寫實例的過程方法，但具有過程方法並不一定意味著它是變量類型。例如，數組類型實現了隨機選擇元素的<gtr=“21”/>方法，當然這不會對數組進行破壞性更改。

可變對象的破壞性操作主要通過方法進行。方法是一個高級過程，它通過將函數<gtr=“25”/>應用到<gtr=“24”/>來更新它。


```erg
i = !1
i.update! old -> old + 1
assert i == 2
```

方法只會將舊內容替換為新值。這是<gtr=“27”/>。


```erg
i = !1
i.set! 2
assert i == 2
```

方法在不更改值的情況下執行操作。


```erg
a = [1, 2, 3].into [Nat; !3]
x = a.freeze_map a: [Nat; 3] -> a.iter().map(i -> i + 1).filter(i -> i % 2 == 0).collect(Array)
```

在多相不變類型中，假定類型的類型參數隱式不變。


```erg
# ImmutType < Type
K T: ImmutType = Class ...
K! T: Type = Class ...
```

在標準庫中，可變類型通常基於不變類型<gtr=“31”/>。但是，<gtr=“32”/>類型和<gtr=“33”/>類型在語言上沒有特殊的關聯，不需要這樣配置。

請注意，有幾種類型的對象可變性。下面我們將討論內置集合類型的不可變/可變類型的含義。


```erg
# 配列型
## 不変型(immutable types)
[T; N]     # 可変操作は実行できない
## 可変型(mutable types)
[T!; N]    # 中身を1つずつ変更できる
[T; !N]    # 可変長、中身は変更不能だが要素の追加・削除で実質変更可能
[!T; N]    # 中身は不変オブジェクトだが、型を変えたものに差し替え可能(型を変えないという操作で実質差し替え可能)
[!T; !N]   # 型、長さを変更可能
[T!; !N]   # 中身、長さを変更可能
[!T!; N]   # 中身、型を変更可能
[!T!; !N]  # ありとあらゆる可変操作を実行できる
```

當然，你沒有必要把所有這些都背下來，熟練使用。對於可變數組類型，只需在想要可變的部分加上，在實際應用中，<gtr=“36”/>，<gtr=“37”/>，<gtr=“38”/>和<gtr=“39”/>四個可以覆蓋大多數情況。

這些排列類型是语法糖，實際類型如下：


```erg
# 実際は4種類の型
[T; N] = Array(T, N)
[T; !N] = Array!(T, !N)
[!T; N] = ArrayWithMutType!(!T, N)
[!T; !N] = ArrayWithMutTypeAndLength!(!T, !N)
[T!; !N] = Array!(T!, !N)
[!T!; N] = ArrayWithMutType!(!T!, N)
[!T!; !N] = ArrayWithMutTypeAndLength!(!T!, !N)
```

另外，可以更改類型就是這樣的意思。


```erg
a = [1, 2, 3].into [!Nat; 3]
a.map!(_ -> "a")
a: [!Str; 3]
```

其他收藏類型也是如此。


```erg
# タプル型
## 不変型(immutable types)
(T, U) # 要素數不変、中身を変更できない
## 可変型(mutable types)
(T!, U) # 要素數不変、最初の要素は変更できる
(T, U)! # 要素數不変、中身を差し替えられる
...
```


```erg
# セット型
## 不変型(immutable types)
{T; N}        # 不変要素數、中身を変更できない
## 可変型(mutable types)
{T!; N}       # 不変要素數、中身を(1つずつ)変更できる
{T; N}!       # 可変要素數、中身は変更不能だが、要素の追加削除で実質可能、中の型を変更可能
{T!; N}!      # 可変要素數、中身も変更できる
...
```


```erg
# 辭書型
## 不変型(immutable types)
{K: V}          # 不変長、中身を変更できない
## 可変型(mutable types)
{K: V!}         # 不変長、値を(1つずつ)変更できる
{K: V}!         # 可変長、中身を変更できないが、要素の追加削除で実質可能、中の型も変更可能
...
```


```erg
# レコード型
## 不変型(immutable types)
{x = Int; y = Str}           # 中身を変更できない
## 可変型(mutable types)
{x = Int!; y = Str}          # xの値を変更できる
{x = Int; y = Str}!          # {x = Int; y = Str}のインスタンスならば何でも差し替えられる
...
```

當時，僅為<gtr=“41”/>的類型<gtr=“42”/>稱為簡單結構類型。簡單結構類型（語義上）也可以稱為沒有內部結構的類型。數組，元組，集，字典和記錄類型並非都是簡單結構類型，而 Int 和篩選類型則是簡單結構類型。


```erg
# 篩型
## 列挙型
{1, 2, 3}    # 1, 2, 3のうちどれか、変更できない
{1, 2, 3}!   # 1, 2, 3のうちどれか、変更できる
## 區間型
1..12  # 1~12のうちどれか、変更できない
1..12! # 1~12のうちどれか、変更できる
## 篩型(一般形)
{I: Int | I % 2 == 0}  # 偶數型、変更できない
{I: Int! | I % 2 == 0} # 偶數型、変更できる
{I: Int | I % 2 == 0}! # 上と全く同じ型、だが上の記法が推奨される
```

根據以上說明，可變類型不僅包括自身可變的類型，也包括內部具有的類型可變的類型。類型（如和<gtr=“44”/>）是內部變量類型，其內部對像是可變的，而實例本身並不是可變的。

對於具有內部結構的類型，<gtr=“46”/>，<gtr=“47”/>可以改變整個對象。它還可以進行局部更改。但是，最好將更改權限限制在局部，因此如果只有<gtr=“48”/>可以更改，則最好將其設置為<gtr=“49”/>。如果類型<gtr=“50”/>沒有內部結構，則該實例只是一個可互換的<gtr=“51”/>框。方法不能更改類型。

---

<span id="1" style="font-size:x-small">1<gtr=“64”/><gtr=“52”/>類型和<gtr=“53”/>類型在語言上沒有特殊關係，這是有意設計。如果存在關聯，則會出現一些不便，例如，如果名稱空間中存在類型<gtr=“54”/>/<gtr=“55”/>，則無法從另一個模塊引入類型<gtr=“56”/>/<gtr=“57”/>。此外，與不可變類型相比，可變類型並不是唯一的。當定義<gtr=“58”/>時，變量子類型<gtr=“59”/>和<gtr=“60”/>可以是<gtr=“61”/>。 <gtr=“62”/></span>