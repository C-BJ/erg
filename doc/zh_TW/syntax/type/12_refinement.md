# 篩子類型（Refinement Type）

Refinement type 是受謂詞表達式約束的類型。枚舉型和區間型是篩子型的一種。

篩型的標準形式是。這意味著它是以滿足<gtr=“8”/>的<gtr=“9”/>為元素的類型。只有<gtr=“10”/>可用於篩型。


```erg
Nat = 0.._
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N >= 3}
```

如果有多個 Pred，請用或<gtr=“12”/>或<gtr=“13”/>分隔。 <gtr=“14”/>和<gtr=“15”/>是相同的意思。

的元素是<gtr=“17”/>。因為它是一種將現有類型的一部分作為要素的類型，就像在篩子上一樣，所以被稱為篩子類型。

稱為（左側）謂詞表達式。它不返回與賦值表達式相同的有意義的值，並且只能在左邊放置模式。也就是說，<gtr=“19”/>等式不能用作篩子謂詞表達式。這一點不同於右邊表達式的謂詞表達式。


```erg
{X: Int | X**2 - 5X + 6 == 0} # SyntaxError: the predicate form is invalid. Only names can be on the left-hand side
```

如果你知道二次方程的解法，你應該可以預測，上面的篩子類型將等同於。然而，Erg 編譯器幾乎沒有代數學知識，因此無法解決右邊的謂詞表達式。

## Smart Cast

定義是很好的，但如果這樣，除了文字以外，似乎很難使用它。要將常規<gtr=“22”/>對像中的奇數提升到<gtr=“23”/>，即將<gtr=“24”/>下鑄到<gtr=“25”/>，必須通過<gtr=“26”/>構造函數。對於篩子類型，常規構造函數<gtr=“27”/>可能會死機，有些輔助構造函數返回<gtr=“29”/>類型<gtr=“28”/>。


```erg
i = Odd.new (0..10).sample!()
i: Odd # or Panic
```

也可以在中用作類型說明。


```erg
# i: 0..10
i = (0..10).sample!()
match i:
    o: Odd ->
        log "i: Odd"
    n: Nat -> # 0..10 < Nat
        log "i: Nat"
```

然而，由於 Erg 當前不是，因此不能進行諸如<gtr=“32”/>之類的次要判斷。

## 列舉型、區間型和篩型

之前介紹的枚舉型和區間型，是篩子型的糖衣句法。將脫糖為<gtr=“34”/>，將<gtr=“35”/>脫糖為<gtr=“36”/>。


```erg
{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I >= 1 and I <= 10}
1..<10 == {I: Int | I >= 1 and I < 10} == {I: Int | I >= 1 and I <= 9}
```

## 篩子模式

可以被重寫為<gtr=“38”/>（常數模式），<gtr=“39”/>可以被重寫為<gtr=“40”/>。


```erg
# メソッド.mは長さ3以上の配列に定義される
Array(T, N | N >= 3)
    .m(&self) = ...
```