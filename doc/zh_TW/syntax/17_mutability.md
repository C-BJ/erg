# Mutability

正如我們已經看到的，Erg 中的所有變量都是不變的。但是 Erg 的對像有一個可變性的概念。以下代碼為示例。


```erg
a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
```

上面的代碼實際上是 Erg 無法實現的。因為不能再賦值。這個代碼可以運行。


```erg
b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
```

雖然最終的結果看起來是一樣的，但其含義卻大相徑庭。是表示<gtr=“10”/>數組的變量，但第一行和第二行所指向的對像不同。只是名稱相同，但內容不同。


```erg
a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
```

過程返回對象所在內存中的地址。

是<gtr=“14”/>的“動態”數組。對象的內容會發生變化，但變量指向相同的內容。


```erg
b = [1,2,3].into [Int; !3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
```


```erg
i = !0
if! True:
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
```

是一個特殊的運算符，稱為<gtr=“17”/>。返回變量的不可變對象。帶有<gtr=“16”/>的對象的行為可以自定義。


```erg
Point = Class {.x = Int; .y = Int}

# この場合.xは可変化し、yは不変のまま
Point! = Class {.x = Int!; .y = Int}
Point!.inc_x! ref! self = self.x.update! x -> x+1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
```

## 常數

與變量不同，常量在所有作用域中指向相同的內容。常量由運算符聲明。


```erg
PI = 3.141592653589
match! x:
    PI => print! "this is pi"
```

常量在全局以下的所有範圍內都是相同的，不能被覆蓋。因此，不能通過進行重新定義。此限制允許你在模式匹配中使用它。在模式匹配中使用<gtr=“20”/>和<gtr=“21”/>是因為它們是常數。此外，常量始終指向不變對象。類型（如<gtr=“22”/>）不能是常量。所有內置類型都是常量，因為它們應該在編譯時確定。也可以生成非常量類型，但不能用於指定類型，只能作為記錄使用。反過來說，類型也可以說是編譯時內容已確定的記錄。

## Variable, Name, Identifier, Symbol

現在，我們來整理一下 Erg 中有關變量的術語。

“變量”（Variable）是一種為對象命名（Name）並允許其重複使用的機制（或指該名稱）。標識符（Identifier）是用於指定變量的語法元素。符號是表示名稱的語法元素和標記。

只有不是符號的字符才是符號，符號是運算符，但不是符號。例如，是標識符和符號。 <gtr=“24”/>也是一個標識符，但它不是一個符號。 <gtr=“25”/>和<gtr=“26”/>是符號。即使<gtr=“27”/>沒有與任何對象關聯，<gtr=“28”/>仍然是 Symbol 和 Identifier，但不是 Variable。形式為<gtr=“29”/>的標識符稱為字段存取器。此外，<gtr=“30”/>形式的標識符稱為下標存取器。

變量和標識符之間的區別，如果說 Erg 語法理論意義上的變量，那麼這兩個變量實際上是相同的。變量和標識符不等效的語言包括 C 語言。在 C 語言中，類型或函數不能賦給變量。 int，main 是標識符，但不是變量（嚴格來說，它可能是可賦值的，但有限制）。但在 Erg 中，“一切都是物體”。函數和類型，甚至運算符都可以賦給變量。

<p align='center'>
    <a href='./16_iterator.md'>Previous</a> | <a href='./18_ownership.md'>Next</a>
</p>