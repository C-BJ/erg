# 術語統一

## 可見性、可見性

使用“Visibility（可見性）”。

## 完全（非、補）

使用否定類型。 Complement 的結果不一定是 Not 型。

## Diff（差分型、排除型、直差型）

使用排除類型。 Diff 的結果不一定是 Not 型。

## Intersection（交集、交集、笛卡爾）

使用交叉類型。不使用笛卡兒積型。這是因為也有將元組視為笛卡兒積型的用法。但是，從屬性部分型的觀點來看，是與 Erg 的 And 型本質上等價的概念。另外，Intersection 的結果不一定是 And 型。例如。

## Nominal subtyping 的翻譯

雖然有記名的/名目的/標稱的部分定型，但是使用記名的部分定型。

## Ratio 型譯詞

使用有理數型。由於 Float 是單獨提供的，所以不稱為浮點數型。

## Union（合併、直和）

使用合併類型。 Union 的結果不一定是 Or 型。

## 類型邊界（Type bound）、類型約束（Type constraint）

量化型、篩子型所給謂詞式的列表。使用類型邊界。

## 子程序，例程，子程序

中描述的相應參數的值。

## 參照透明/不透明，有/無副作用

使用有/無副作用。

## 標識符、代數、變量、名稱、符號

原來的意思是，

* 符號（Symbol）：非字符串對象（未括在“”中）的純文本源代碼字符（符號、控製字符等除外）。 Ruby 和 Lisp 等中作為基本類型的符號存在，但在 Erg 中不被作為對象處理。
* 標識符（Identifier）：指向（也可以）某個對象的符號，而不是保留字。例如，在 Python 中，class 和 def 不能作為標識符使用。由於 Erg 中沒有保留字，所以除去一部分符號的所有符號都可以作為標識符使用。
* 名稱（Name）：幾乎等同於標識符。在 Erg 中也有與代數相同的意思使用。
* 代數名（Algebra name）：在 Erg 中等同於標識符。在 C 語言中，函數名是標識符，但不是代數名。 “代數”是指能夠用（變量賦值運算符）或<gtr=“4”/>（常量賦值運算符）賦值對象的語言功能本身。


```erg
代數名 <: (名前 == 識別子) <: シンボル
変數 + 定數 == 代數
```

但是，本來應該被稱為“代數”的多被稱為“變量”。這是數學術語的影響。值的內容可能變化的變量是可互斥變量，值的內容不變的變量是可互斥變量。另外，常數一定是可變的。

Erg 中代數名，不使用名稱，用標識符統一。但是，一般來說，的<gtr=“6”/>被稱為“變量 v”（“Variable v”），<gtr=“7”/>的<gtr=“8”/>被稱為“常數 C”（“Constant C”）。

## 屬性、字段和特性

屬性，使用屬性。順便一提，記錄是指在沒有類的情況下可以定義具有要素屬性的對象的功能。

## 應用（Application）、調用（Call）

通過向子程序對象提供參數來獲得結果。使用調用（Call）。因為 Application 具有“應用軟件”的用法。

## 數組、列表

使用 Array。這是因為 Erg 的排列（通常）是在存儲器上連續排列的。 List 指的是所謂的連接列表，或者作為 Python 的數據類型的列表。

## 過程，過程

與過程一致。子例程是函數（和運算符）、過程和方法的總稱。 Callable 是安裝了的全部。

## Lambda 函數、Lambda 表達式、匿名函數、匿名函數

統一為無名函數。英語中為了縮短字數可以使用 Lambda，但正式名稱是 Anonymous function。另外，Erg 的無名函數不是匿名的，所以不使用匿名函數。