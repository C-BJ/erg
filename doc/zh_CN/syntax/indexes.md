# index

See [here](../API/index.md) for APIs not in this index.
See [here](../dev_guide/terms.md) for terminology.

## symbol

* !
  * !-type → [mutable type](./type/mut.md)
* [&#35;](./00_basic.md/#comment)
*$
* %
* &
  * &&
* &prime; (single quote)
* &lpar;&rpar;
* &ast;
  * [*-less multiplication](./01_literal.md/#less-multiplication)
* &plus; (prefix)
  * &plus;_ → &plus; (prefix)
* &plus; (infix)
* ,
* &minus; (prefix)
  * &minus;_ → &minus; (prefix)
* &minus; (infix)
  * &minus;>
* . → [Visibility]
* /
* :
  * :: → [visibility]
* ;
* &lt;
  * &lt;:
  * &lt;&lt;
  * &lt;=
* =
  * ==
  * =>
* &gt;
  * &gt;&gt;
  * &gt;=
* ?
* @
* []
* \
* ^
  * ^^
* _
  * &#95;+&#95; → &plus; (infix)
  * &#95;-&#95; → &minus; (infix)
*``
* {}
  * {} type
* {:}
* {=}
  * {=} type
* |
  * ||
* ~

## alphabet

### A

* [algebraic&nbsp;type]
* [And]
* [and]
* [assert]
* [attribute]

###B

* [Base]
* [Bool]

### C

* [Class]

###D

*Deprecated
* [distinct]

###E

* [enum&nbsp;type]
*[Eq]
*[Erg]

###F

*[for]

###G

###H

### I

* [if]
* [import]
* [in]
* [Int]

###J

###K

### L

* let-polymorphism → [rank 1 polymorphism]
* [log]

###M

* [match]

###N

*[Nat]
* Never
*None
*None
*[Not]
* [not]

###O

* [Option]
* [Or]
* [or]
*[Ord]

###P

* panic
* [print!](./../API/procs.md#print)
* [Python]

###Q

### R

* ref
*ref!
* [Result]
*[rootobj]

###S

*self
* [Self](./type/special.md)
* [side-effect](./07_side_effect.md)
*[Str]

###T

* Traits
* [True]
* [Type]
* [type]

###U

###V

### W

* [while!]

###X

###Y

###Z

## A line

* [Assertion]
* value object
* [Attachment patch](./29_decorator.md#attach)
* Ad-hoc polymorphism → [No overloading](./type/overloading.md)
* Attribute → [Attribute]
* arity
* [dependent type](./type/dependent_type.md)
* immutable → [immutable]
* Argument → [Argument]
* instance
* [instant block](./00_basic.md# expression separator)
* index
* [indent](./00_basic.md#indent)
* alias
* error
  * [Error handling]
* [operator](./06_operator.md)
  * [operator binding strength]
* Override
* [No overloading](./type/overloading.md)
* Offside rule → [indent](./00_basic.md#indent)
* [object]
  * Object-orientation
* Operand → [operand](./06_operator.md)
* operator → [operator](./06_operator.md)

## Ka line

* [Kind](./type/advanced/kind.md)
* [Visibility]
* [type]
  * [type specification]
  * [type erasure](./type/advanced/erasure.md)
  * [type inference]
  * [type annotation](./type/conv_type.md)
  * [type argument]
  * [type addition](./type/advanced/erasure.md)
  * [type variable](./type/type_variable.md)
  * [type constraint]
* [Guard]
* Encapsulation
* [variable]
  * [mutable object]
  * [variable]
  * [variable reference]
  * [variable array]
  * [variable arguments]
* [function](./04_function.md)
  * [Functional programming] (./23_scope.md#Avoiding mutable state Functional programming)
* base type
* Signed
  * [Named type] → [Class](./type/04_class.md)
  * [Annunciation]
  * [nominal subtype](./type/05_nst_vs_sst.md)
* Capture → [Closure]
* [covariant]
* [keyword argument]
* empty set → [{}]
* section
  * [Interval type](./type/11_interval.md)
  * interval operator
* built-in
  * [Built-in type]
  * [Built-in functions](./05_builtin_funcs.md)
  * [Built-in procedures](./09_builtin_procs.md)
* [class](./type/04_class.md)
* [Closure]
* [global variables]
* [Clone]
* [Inheritance](./type/07_inheritance.md)
* high floor
  * [Advanced kind](./type/advanced/kind.md)
  * higher order type
  * Higher-order functions
* [public variable]
* [structural subtype]
* ~~backreference~~ → [backreference]
* [copy]
* comment
* [Collection](./10_array.md)
* colon → [:]
* [constructor](./type/04_class.md)
* container
* Compiler
* [compile-time calculation](./04_function.md#compile-time function)
* Comma → [,]

## sa line

* recursion
  * recursive
  * [Recursive function](./04_function.md#Recursive function)
* subscript → [index]
* [Subtyping Polymorphism](./type/overloading.md)
* Subroutine
* [reference] (./18_memory_management.md# borrowed)
  * reference object
  * [Reference counting (RC)] (./18_memory_management.md# memory management)
  * Reference equality → [side effect](./07_side_effect.md)
* [identifier](./02_variable.md/# assignment)
* Signature
  * type signature
* [dict](./11_dict.md)
* [Natural number] → [Nat]
* generics → [universal type]
* Generator
* [projective type]
* Borrow → [Reference](./18_memory_management.md#Borrow)
* [Shadowing] (./02_name.md# variables)
* Species → [Kind](./type/advanced/kind.md)
* [Set] → [Set]
* predicate
  * [predicate function]
* Conditional branch
* [Ownership]
* Boolean → [Bool]
* Singleton
* [Symbol] → [Identifier](./02_name.md)
  * [symbolization]
* [script](./00_basic.md# script)
* scope
* Spread operator → [expansion assignment]
* [slice](./10_array.md#slice)
* control character
* [Integer] → [Int]
* [set](./12_set.md)
* Semicolon → [;]
* [Declaration](./03_declaration.md)
* full name
  * Universal type → [polymorphic type](./type/quantified.md)
    * closed universal
    * Open Universal
  * universal function → polycorrelation function
  * universal quantification
* prefix operator
* mutually recursive
* subscript → [index]
* [attribute]
  * [attribute subtype]

## Ta line

* [algebra](./02_name.md)
  * [Algebraic type](./type/13_algebraic.md)
  * algebraic data types
* [assignment](./02_variable.md/#assignment)
* Multiple
  * [Multiple inheritance](./type/07_inheritance.md/#Prohibition of multiple inheritance)
  * Multiple assignment
  * Overloading → [No overloading]
* Polyphase
  * [polymorphic type](./type/quantified.md)
  * polycorrelation coefficient
* polymorphism → [polymorphism]
* duck typing
* [tuple](./11_tuple.md)
* Single-phase
  * Single phase
  * Single-phase type
  * Single correlation coefficient
* [lazy initialization]
* extraction assignment
* Abstract syntax tree → [AST]
* infix operator
* [constant](./02_name.md/#constant)
  * [constant type](./type/advanced/const.md)
  * [constant expression](./type/advanced/const.md)
*[definition]
* provided attributes
* [Apply]
* [decorator](./29_decorator.md)
* Destructor
* procedure → [procedure](./08_procedure.md)
* [default arguments](./04_function.md/#default arguments default-parameters)
* expand
  * [expansion operator]
  * [expansion assignment]
* [special format](./../API/special.md)
* Anonymous function → [anonymous function](./20_lambda.md)
* Dot operator (`.`) → [attribute reference]
* Top
  * Top type → [Structural Object]
  * Top class → [Object]
* [trait](./type/03_trait.md)

## na line

* [Comprehension](./27_comprehension.md)
* ~~Infix operator~~ → [Infix operator]
* [namespace]

## is a line

* [Array](./10_array.md)
* [derived type](./type/variances.md/# user-defined type variations)
* [pattern (match)](./26_pattern_matching.md)
* [package](./33_package_ssystem.md)
* Hashmap → [dictionary](./11_dict.md)
* [patch](./type/07_patch.md)
* public variable → [public variable](./19_visibility.md)
* Parameter → [argument](./04_function.md)
* [Parametric Polymorphism](./type/overloading.md)
* [contravariant](./type/advanced/variance.md)
* Compare
  * [comparison operator]
  * [comparable type]
* [private variable](./19_visibility.md)
* standard
  * standard output
  * standard input
  * standard library
* [side effect](./07_side_effect.md)
* Complex number → [Complex]
* [Float] → [Float]
* Private Variable → [Private Variable]
* Boolean algebra → [Bool]
* [procedure](./08_procedure.md)
* [argument](./04_function.md)
* Partial Typing → [Subtyping]
* [immutable]
  * [immutable object]
  * [immutable type]
  * [immutable reference]
* [sieve type](./type/12_refinement.md)
* [block]
* deconstruction assignment
* [variable](./02_variable.md)
* Bottom
  * bottom type → [{}]
  * Bottom class → [Never]
* [Polymorphism]

## ma line

* ~~ prefix operator ~~ → prefix operator
* [Marker type](./type/advanced/marker_trait.md)
* [anonymous function](./21_lambda.md)
* mutable → [mutable]
* [Move]
* 方法
* Metacharacter
* [module](./24_module.md)
* [String] → [Str]
  * [String interpolation](./01_literal.md/#str literal)
* Return value

## or line

* [Ghost type](./type/advanced/phantom.md)
* request attributes
* [element]
* [call]

## Ra line

* [Library]
* Lambda expression → [anonymous function](./20_lambda.md)
* rank
  * [Rank 2 Polymorphism](./type/advanced/rank2type.md)
* [literal](./01_literal.md)
  * [literal identifier](./18_naming_rule.md/#literal identifier)
* [quantified](./type/quantified.md)
* [Layout](./type/mut.md)
* [enum](./type/10_enum.md)
* [record](./12_record.md)
  * [record type]
  * Record Polymorphism → [Column Polymorphism]
* [column polymorphic]
* [local variable](./19_visibility.md)

## line

* Wildcard