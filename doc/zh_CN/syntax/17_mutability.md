# Mutability

正如我们已经看到的，Erg 中的所有变量都是不变的。但是 Erg 的对象有一个可变性的概念。以下代码为示例。


```erg
a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
```

上面的代码实际上是 Erg 无法实现的。因为不能再赋值。这个代码可以运行。


```erg
b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
```

虽然最终的结果看起来是一样的，但其含义却大相径庭。是表示<gtr=“10”/>数组的变量，但第一行和第二行所指向的对象不同。只是名称相同，但内容不同。


```erg
a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
```

过程返回对象所在内存中的地址。

是<gtr=“14”/>的“动态”数组。对象的内容会发生变化，但变量指向相同的内容。


```erg
b = [1,2,3].into [Int; !3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
```


```erg
i = !0
if! True:
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
```

是一个特殊的运算符，称为<gtr=“17”/>。返回变量的不可变对象。带有<gtr=“16”/>的对象的行为可以自定义。


```erg
Point = Class {.x = Int; .y = Int}

# この場合.xは可変化し、yは不変のまま
Point! = Class {.x = Int!; .y = Int}
Point!.inc_x! ref! self = self.x.update! x -> x+1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
```

## 常数

与变量不同，常量在所有作用域中指向相同的内容。常量由运算符声明。


```erg
PI = 3.141592653589
match! x:
    PI => print! "this is pi"
```

常量在全局以下的所有范围内都是相同的，不能被覆盖。因此，不能通过进行重新定义。此限制允许你在模式匹配中使用它。在模式匹配中使用<gtr=“20”/>和<gtr=“21”/>是因为它们是常数。此外，常量始终指向不变对象。类型（如<gtr=“22”/>）不能是常量。所有内置类型都是常量，因为它们应该在编译时确定。也可以生成非常量类型，但不能用于指定类型，只能作为记录使用。反过来说，类型也可以说是编译时内容已确定的记录。

## Variable, Name, Identifier, Symbol

现在，我们来整理一下 Erg 中有关变量的术语。

“变量”（Variable）是一种为对象命名（Name）并允许其重复使用的机制（或指该名称）。标识符（Identifier）是用于指定变量的语法元素。符号是表示名称的语法元素和标记。

只有不是符号的字符才是符号，符号是运算符，但不是符号。例如，是标识符和符号。<gtr=“24”/>也是一个标识符，但它不是一个符号。<gtr=“25”/>和<gtr=“26”/>是符号。即使<gtr=“27”/>没有与任何对象关联，<gtr=“28”/>仍然是 Symbol 和 Identifier，但不是 Variable。形式为<gtr=“29”/>的标识符称为字段存取器。此外，<gtr=“30”/>形式的标识符称为下标存取器。

变量和标识符之间的区别，如果说 Erg 语法理论意义上的变量，那么这两个变量实际上是相同的。变量和标识符不等效的语言包括 C 语言。在 C 语言中，类型或函数不能赋给变量。int，main 是标识符，但不是变量（严格来说，它可能是可赋值的，但有限制）。但在 Erg 中，“一切都是物体”。函数和类型，甚至运算符都可以赋给变量。

<p align='center'>
    <a href='./16_iterator.md'>Previous</a> | <a href='./18_ownership.md'>Next</a>
</p>
