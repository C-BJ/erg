# 存在类型

如果有对应于应有尽有的全称型，那么自然会有对应于应有尽有的存在型。存在型并不难。只是你没有这样的意识，就已经知道了你的存在型。


```erg
T: Trait
f x: T = ...
```

上面的trait被用作存在类型。相反，下面的<gtr=“6”/>只是trait，<gtr=“7”/>是全称类型。


```erg
f|X <: T| x: X = ...
```

事实上，存在类型被全称类型所取代。那么为什么会存在所谓的存在型呢？首先，正如上面所见，存在类型不涉及类型变量，因此可以简化类型指定。此外，由于可以移除类型变量，因此可以配置全称类型，使其超过等级 2。


```erg
show_map f: (|T| T -> T), arr: [Show; _] =
    arr.map x ->
        y = f x
        log y
        y
```

但是，一看就知道，存在型会忘却、扩大原来的型，所以不想扩大返回值的型等情况下，需要使用全称型。相反，只作为参数接收而与返回值无关的类型可以用存在类型来描述。


```erg
# id(1): 我希望它是一个 Int
id|T|(x: T): T = x
# |S <: Show|(s: S) -> () 是多余的
show(s: Show): () = log s
```

顺便说一下，类不称为存在类型。因为预先决定了成为那个要素的对象。存在型是指满足某一trait的所有类型，实际上不知道要代入什么类型。
