# 筛子类型（Refinement Type）

Refinement type 是受谓词表达式约束的类型。枚举型和区间型是筛子型的一种。

筛型的标准形式是。这意味着它是以满足<gtr=“8”/>的<gtr=“9”/>为元素的类型。只有<gtr=“10”/>可用于筛型。


```erg
Nat = 0.._
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N >= 3}
```

如果有多个 Pred，请用或<gtr=“12”/>或<gtr=“13”/>分隔。<gtr=“14”/>和<gtr=“15”/>是相同的意思。

的元素是<gtr=“17”/>。因为它是一种将现有类型的一部分作为要素的类型，就像在筛子上一样，所以被称为筛子类型。

称为（左侧）谓词表达式。它不返回与赋值表达式相同的有意义的值，并且只能在左边放置模式。也就是说，<gtr=“19”/>等式不能用作筛子谓词表达式。这一点不同于右边表达式的谓词表达式。


```erg
{X: Int | X**2 - 5X + 6 == 0} # SyntaxError: the predicate form is invalid. Only names can be on the left-hand side
```

如果你知道二次方程的解法，你应该可以预测，上面的筛子类型将等同于。然而，Erg 编译器几乎没有代数学知识，因此无法解决右边的谓词表达式。

## Smart Cast

定义是很好的，但如果这样，除了文字以外，似乎很难使用它。要将常规<gtr=“22”/>对象中的奇数提升到<gtr=“23”/>，即将<gtr=“24”/>下铸到<gtr=“25”/>，必须通过<gtr=“26”/>构造函数。对于筛子类型，常规构造函数<gtr=“27”/>可能会死机，有些辅助构造函数返回<gtr=“29”/>类型<gtr=“28”/>。


```erg
i = Odd.new (0..10).sample!()
i: Odd # or Panic
```

也可以在中用作类型说明。


```erg
# i: 0..10
i = (0..10).sample!()
match i:
    o: Odd ->
        log "i: Odd"
    n: Nat -> # 0..10 < Nat
        log "i: Nat"
```

然而，由于 Erg 当前不是，因此不能进行诸如<gtr=“32”/>之类的次要判断。

## 列举型、区间型和筛型

之前介绍的枚举型和区间型，是筛子型的糖衣句法。将脱糖为<gtr=“34”/>，将<gtr=“35”/>脱糖为<gtr=“36”/>。


```erg
{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I >= 1 and I <= 10}
1..<10 == {I: Int | I >= 1 and I < 10} == {I: Int | I >= 1 and I <= 9}
```

## 筛子模式

可以被重写为<gtr=“38”/>（常数模式），<gtr=“39”/>可以被重写为<gtr=“40”/>。


```erg
# メソッド.mは長さ3以上の配列に定義される
Array(T, N | N >= 3)
    .m(&self) = ...
```
