# 术语统一

## 可见性、可见性

使用“Visibility（可见性）”。

## 完全（非、补）

使用否定类型。Complement 的结果不一定是 Not 型。

## Diff（差分型、排除型、直差型）

使用排除类型。Diff 的结果不一定是 Not 型。

## Intersection（交集、交集、笛卡尔）

使用交叉类型。不使用笛卡儿积型。这是因为也有将元组视为笛卡儿积型的用法。但是，从属性部分型的观点来看，是与 Erg 的 And 型本质上等价的概念。另外，Intersection 的结果不一定是 And 型。例如。

## Nominal subtyping 的翻译

虽然有记名的/名目的/标称的部分定型，但是使用记名的部分定型。

## Ratio 型译词

使用有理数型。由于 Float 是单独提供的，所以不称为浮点数型。

## Union（合并、直和）

使用合并类型。Union 的结果不一定是 Or 型。

## 类型边界（Type bound）、类型约束（Type constraint）

量化型、筛子型所给谓词式的列表。使用类型边界。

## 子程序，例程，子程序

中描述的相应参数的值。

## 参照透明/不透明，有/无副作用

使用有/无副作用。

## 标识符、代数、变量、名称、符号

原来的意思是，

* 符号（Symbol）：非字符串对象（未括在“”中）的纯文本源代码字符（符号、控制字符等除外）。Ruby 和 Lisp 等中作为基本类型的符号存在，但在 Erg 中不被作为对象处理。
* 标识符（Identifier）：指向（也可以）某个对象的符号，而不是保留字。例如，在 Python 中，class 和 def 不能作为标识符使用。由于 Erg 中没有保留字，所以除去一部分符号的所有符号都可以作为标识符使用。
* 名称（Name）：几乎等同于标识符。在 Erg 中也有与代数相同的意思使用。
* 代数名（Algebra name）：在 Erg 中等同于标识符。在 C 语言中，函数名是标识符，但不是代数名。“代数”是指能够用（变量赋值运算符）或<gtr=“4”/>（常量赋值运算符）赋值对象的语言功能本身。


```erg
代数名 <: (名前 == 識別子) <: シンボル
変数 + 定数 == 代数
```

但是，本来应该被称为“代数”的多被称为“变量”。这是数学术语的影响。值的内容可能变化的变量是可互斥变量，值的内容不变的变量是可互斥变量。另外，常数一定是可变的。

Erg 中代数名，不使用名称，用标识符统一。但是，一般来说，的<gtr=“6”/>被称为“变量 v”（“Variable v”），<gtr=“7”/>的<gtr=“8”/>被称为“常数 C”（“Constant C”）。

## 属性、字段和特性

属性，使用属性。顺便一提，记录是指在没有类的情况下可以定义具有要素属性的对象的功能。

## 应用（Application）、调用（Call）

通过向子程序对象提供参数来获得结果。使用调用（Call）。因为 Application 具有“应用软件”的用法。

## 数组、列表

使用 Array。这是因为 Erg 的排列（通常）是在存储器上连续排列的。List 指的是所谓的连接列表，或者作为 Python 的数据类型的列表。

## 过程，过程

与过程一致。子例程是函数（和运算符）、过程和方法的总称。Callable 是安装了的全部。

## Lambda 函数、Lambda 表达式、匿名函数、匿名函数

统一为无名函数。英语中为了缩短字数可以使用 Lambda，但正式名称是 Anonymous function。另外，Erg 的无名函数不是匿名的，所以不使用匿名函数。
